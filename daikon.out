/Users/remywang/daikon//java/daikon/inv/unary/scalar/Modulus.java
for (Iterator<Invariant> itor = ppt.invs.iterator() ; itor.hasNext() ;)
{
  Invariant inv = itor.next();
  if (inv instanceof Modulus)
    return (Modulus) inv;
}haha 
1
/Users/remywang/daikon//java/daikon/inv/unary/scalar/Positive.java
0
/Users/remywang/daikon//java/daikon/inv/InvariantStatus.java
0
/Users/remywang/daikon//java/daikon/inv/Invariant.java
for (Iterator<Invariant> itor = ppt.invs.iterator() ; itor.hasNext() ;)
{
  Invariant inv = itor.next();
  if (inv.getClass() == invclass)
    return inv;
}haha 
1
/Users/remywang/daikon//java/daikon/inv/IsEqualityComparison.java
0
/Users/remywang/daikon//java/daikon/inv/FeatureExtractor.java
for (Iterator<IntDoublePair> all = allFeatures.iterator() ; all.hasNext() ;)
{
  IntDoublePair current = all.next();
  if (numbersToNames.containsKey(current))
  {
    String currentName = numbersToNames.get(current);
    if (currentName.endsWith("Bool"))
      names.println((currentName + ":0.0, 1.0."));
    else
      if (currentName.endsWith("Float"))
        names.println((currentName + ": continuous."));
      else
        if (currentName.endsWith("Int"))
          names.println((currentName + ": continuous."));
        else
          throw new IOException("All feature names must end with one of " + "Float, Bool, or Int." + lineSep + "Error: " + currentName + lineSep);
  }
  else
    throw new IOException("Feature " + current.number + " not included in .names file");
}haha 
for (Iterator<IntDoublePair> j = allFets.iterator() ; j.hasNext() ;)
{
  IntDoublePair jguy = j.next();
  if (jguy.number == current.number)
    contains = true;
}haha 
for (Iterator<IntDoublePair> fets = allFets.iterator() ; fets.hasNext() ;)
{
  IntDoublePair fet = fets.next();
  output.print((df.format(fet.value) + ","));
}haha 
for (Iterator<IntDoublePair> fets = features.get(i).iterator() ; fets.hasNext() ;)
{
  IntDoublePair fet = fets.next();
  if (fet.value > THRESHOLD)
    output.print((fet.number + ":" + df.format(fet.value) + " "));
}haha 
for (Iterator<IntDoublePair> fets = features.get(i).iterator() ; fets.hasNext() ;)
{
  IntDoublePair fet = fets.next();
  output.print((fet.number + " " + df.format(fet.value) + " "));
}haha 
for (Iterator<IntDoublePair> it = getReflectFeatures(varInfos[i], lookup).iterator() ; it.hasNext() ;)
{
  IntDoublePair current = it.next();
  answer.add(new IntDoublePair((current.number + i + 1), current.value));
  answer.add(current);
}haha 
for (Iterator<IntDoublePair> iter = answer.iterator() ; iter.hasNext() ;)
{
  IntDoublePair current = iter.next();
  if (!index.contains(new Integer(current.number)))
    final_answer.add(current);
  index.add(new Integer(current.number));
}haha 
for (Iterator<String> i = neg.iterator() ; i.hasNext() ;)
{
  String vector = i.next();
  if (!pos.contains(vector))
  {
    if (type.equals("C5"))
      negvectors.add((vector + "bad"));
    else
      if (type.equals("SVMfu"))
        negvectors.add((vector + "-1"));
  }
}haha 
8
/Users/remywang/daikon//java/daikon/inv/OneOf.java
0
/Users/remywang/daikon//java/daikon/inv/Equality.java
for (Iterator<VarInfo> i = variables.iterator() ; i.hasNext() ;)
{
  VarInfo vi = i.next();
  if (debug.isLoggable(Level.FINE))
  {
    debug.fine(("  " + vi.name.name() + " [" + vi.comparability + "]"));
  }
  Assert.assertTrue((vi.ppt == leader.ppt));
  Assert.assertTrue(vi.comparableNWay(leader));
  Assert.assertTrue(VarComparability.comparable(leader, vi), ("not comparable " + leader.name.name() + " " + vi.name.name() + " at ppt " + ppt.parent.name()));
  Assert.assertTrue((vi.rep_type.isArray() == leader.rep_type.isArray()));
  vi.equalitySet = this;
}haha 
for (Iterator<VarInfo> i = vars.iterator() ; i.hasNext() ;)
{
  VarInfo var = i.next();
  if (!start)
  {
    result.append(" == ");
  }
  else
  {
    start = false;
  }
  result.append(var.name.name());
  result.append(("[" + var.varinfo_index + "]"));
  if (var == leader())
    result.append("L");
}haha 
for (Iterator<VarInfo> i = vars.iterator() ; i.hasNext() ;)
{
  VarInfo other = i.next();
  if (other.isDerivedSequenceMinMaxSum())
  {
    break;
  }
  if (other.isValidEscExpression())
  {
    valid_equiv.add(other);
  }
  else
  {
    invalid_equiv.add(other);
  }
}haha 
for (Iterator<VarInfo> iVars = vars.iterator() ; iVars.hasNext() ;)
{
  VarInfo var = iVars.next();
  if (newLeader == null)
  {
    newLeader = var;
  }
  else
    if (newLeader.isDerivedParamAndUninteresting() && !var.isDerivedParamAndUninteresting())
    {
      newLeader = var;
    }
    else
      if (var.isDerivedParamAndUninteresting() && !newLeader.isDerivedParamAndUninteresting())
      {
      }
      else
        if (var.derivedDepth() < newLeader.derivedDepth())
        {
          newLeader = var;
        }
        else
          if (var.derivedDepth() > newLeader.derivedDepth())
          {
          }
          else
            if (var.name.inOrderTraversal().size() < newLeader.name.inOrderTraversal().size())
            {
              newLeader = var;
            }
}haha 
for (Iterator<VarInfo> i = vars.iterator() ; i.hasNext() ;)
{
  VarInfo var = i.next();
  Assert.assertTrue(VarComparability.comparable(leader, var), ("not comparable: " + leader.name.name() + " " + var.name.name() + " at ppt " + ppt.parent.name()));
}haha 
5
/Users/remywang/daikon//java/daikon/inv/filter/InvariantFilters.java
for (Iterator<VariableFilter> iter = variableFilters.iterator() ; iter.hasNext() ;)
{
  InvariantFilter filter = iter.next();
  if (!filter.shouldDiscard(invariant))
  {
    hasAnyVariable = true;
  }
}haha 
for (Iterator<VariableFilter> iter = variableFilters.iterator() ; iter.hasNext() ;)
{
  InvariantFilter filter = iter.next();
  if (filter.shouldDiscard(invariant))
  {
    if (invariant.logOn())
      invariant.log(("Failed ALL_VARIABLES filter" + filter.getClass().getName()));
    return filter;
  }
}haha 
for (Iterator<InvariantFilter> iter = propertyFilters.iterator() ; iter.hasNext() ;)
{
  InvariantFilter filter = iter.next();
  if (invariant.logDetail() || df.isLoggable(Level.FINE))
  {
    invariant.log(df, ("applying " + filter.getClass().getName()));
  }
  if (filter.shouldDiscard(invariant))
  {
    if (invariant.logOn() || df.isLoggable(Level.FINE))
      invariant.log(df, ("failed " + filter.getClass().getName() + ": " + invariant.format()));
    return filter;
  }
}haha 
for (Iterator<InvariantFilter> iter = propertyFilters.iterator() ; iter.hasNext() ;)
{
  InvariantFilter filter = iter.next();
  if (filter.getDescription().equals(description))
  {
    answer = filter;
  }
}haha 
for (Iterator<InvariantFilter> iter = propertyFilters.iterator() ; iter.hasNext() ;)
{
  InvariantFilter filter = iter.next();
  filter.turnOn();
}haha 
for (Iterator<InvariantFilter> iter = propertyFilters.iterator() ; iter.hasNext() ;)
{
  InvariantFilter filter = iter.next();
  filter.turnOff();
}haha 
for (Iterator<VariableFilter> iter = variableFilters.iterator() ; iter.hasNext() ;)
{
  VariableFilter vf = iter.next();
  if (vf.getVariable().equals(variable))
  {
    return true;
  }
}haha 
7
/Users/remywang/daikon//java/daikon/inv/OutputFormat.java
0
/Users/remywang/daikon//java/daikon/inv/InvDef.java
0
/Users/remywang/daikon//java/daikon/inv/DiscardCode.java
0
/Users/remywang/daikon//java/daikon/PptTopLevel.java
for (Iterator<PptSplitter> ii = splitters.iterator() ; ii.hasNext() ;)
{
  PptSplitter ppt_split = ii.next();
  ppt_split.add_bottom_up(vt, count);
}haha 
for (Iterator<PptSlice> j = views_iterator() ; j.hasNext() ;)
{
  PptSlice slice = j.next();
  if (slice instanceof PptSlice1)
    slice1_cnt++;
  else
    if (slice instanceof PptSlice2)
      slice2_cnt++;
    else
      if (slice instanceof PptSlice3)
        slice3_cnt++;
}haha 
for (Iterator<PptSlice> j = views_iterator() ; j.hasNext() ;)
{
  PptSlice slice = j.next();
  if (slice instanceof PptSlice1)
    debugInstantiate.fine((" : " + slice.var_infos[0].name.name() + ": " + slice.var_infos[0].file_rep_type + ": " + slice.var_infos[0].rep_type + ": " + slice.var_infos[0].equalitySet.shortString()));
  if (false)
  {
    for (int k = 0 ; k < slice.invs.size() ; k++)
    {
      Invariant inv = slice.invs.get(k);
      debugInstantiate.fine(("-- invariant " + inv.format()));
    }
  }
}haha 
for (Iterator<PptSlice> j = views_iterator() ; j.hasNext() ;)
{
  PptSlice slice = j.next();
  if (slice instanceof PptSlice2)
    debugInstantiate.fine((" : " + slice.var_infos[0].name.name() + " : " + slice.var_infos[1].name.name()));
}haha 
for (Iterator<PptSlice> j = views_iterator() ; j.hasNext() ;)
{
  PptSlice slice = j.next();
  if (slice instanceof PptSlice3)
    debugInstantiate.fine((" : " + slice.var_infos[0].name.name() + " : " + slice.var_infos[1].name.name() + " : " + slice.var_infos[2].name.name()));
}haha 
for (Iterator<PptSlice> i = views_iterator() ; i.hasNext() ;)
{
  PptSlice slice = i.next();
  if (slice.invs.size() == 0)
    continue;
  weakened_invs.addAll(slice.add(vt, count));
}haha 
for (Iterator<PptSlice> j = views_iterator() ; j.hasNext() ;)
{
  PptSlice slice = j.next();
  inv_cnt += slice.invs.size();
}haha 
for (Iterator<PptSlice> j = views_iterator() ; j.hasNext() ;)
{
  PptSlice slice = j.next();
  for (int i = 0 ; i < slice.arity() ; i++)
  {
    if (is_constant(slice.var_infos[i]))
    {
      const_cnt++;
      break;
    }
  }
}haha 
for (Iterator<PptSlice> j = views_iterator() ; j.hasNext() ;)
{
  PptSlice slice = j.next();
  for (int i = 0 ; i < slice.arity() ; i++)
  {
    if (is_constant(slice.var_infos[i]))
    {
      const_cnt += slice.invs.size();
      break;
    }
  }
}haha 
for (Iterator<PptSlice> i = views_iterator() ; i.hasNext() ;)
{
  PptSlice slice = i.next();
  log.fine(("Slice: " + slice));
  for (Iterator<Invariant> j = slice.invs.iterator() ; j.hasNext() ;)
  {
    Invariant inv = j.next();
    log.fine(("-- " + inv.format() + (NIS.is_suppressor(inv.getClass()) ? "[suppressor]" : "") + (inv.is_false() ? " [falsified]" : " ")));
  }
}haha 
for (Iterator<Invariant> j = slice.invs.iterator() ; j.hasNext() ;)
{
  Invariant inv = j.next();
  log.fine(("-- " + inv.format() + (NIS.is_suppressor(inv.getClass()) ? "[suppressor]" : "") + (inv.is_false() ? " [falsified]" : " ")));
}haha 
for (Iterator<PptSlice> j = views_iterator() ; j.hasNext() ;)
{
  PptSlice slice = j.next();
  for (int k = 0 ; k < slice.invs.size() ; k++)
  {
    Invariant inv = slice.invs.get(k);
    Cnt cnt = inv_map.get(inv.getClass());
    if (cnt == null)
    {
      cnt = new Cnt();
      inv_map.put(inv.getClass(), cnt);
    }
    cnt.cnt++;
  }
}haha 
for (Iterator<Invariant> i = rm_list.iterator() ; i.hasNext() ;)
{
  Invariant inv = i.next();
  inv.ppt.removeInvariant(inv);
}haha 
for (Iterator<PptRelation> ii = children.iterator() ; ii.hasNext() ;)
{
  PptRelation rel = ii.next();
  if (rel.getRelationType() == PptRelation.EXIT_EXITNN)
    exit_points.add(rel.child);
}haha 
for (Iterator<PptSlice> iPivoted = pivoted.iterator() ; iPivoted.hasNext() ;)
{
  PptSlice oPivoted = iPivoted.next();
  addSlice(oPivoted);
  if (debugEqualTo.isLoggable(Level.FINE))
  {
    debugEqualTo.fine(("  Readded: " + oPivoted));
  }
}haha 
for (Iterator<Invariant> _invs = all.iterator() ; _invs.hasNext() ;)
{
  Invariant inv = _invs.next();
  if (test.include(inv))
  {
    String fmt = inv.format_using(OutputFormat.SIMPLIFY);
    if (!format_simplify_problem(fmt))
    {
      printing.add(inv);
    }
  }
}haha 
for (Iterator<PptConditional> i = cond_iterator() ; i.hasNext() ;)
{
  PptConditional currentCondView = i.next();
  currentCondView.processOmissions(omitTypes);
}haha 
for (Iterator<PptSlice> i = viewsAsCollection().iterator() ; i.hasNext() ;)
{
  PptSlice slice = i.next();
  slice.repCheck();
}haha 
for (Iterator<PptSlice> i = viewsAsCollection().iterator() ; i.hasNext() ;)
{
  PptSlice slice = i.next();
  result.append((Global.lineSep + slice.toString()));
}haha 
for (Iterator<VarInfo> j = vars.iterator() ; j.hasNext() ;)
{
  VarInfo v = j.next();
  if (set_str != "")
    set_str += ",";
  set_str += v.name.name();
  if (v.missingOutOfBounds())
    set_str += "{MOB}";
}haha 
for (Iterator<PptRelation> i = parents.iterator() ; i.hasNext() ;)
{
  PptRelation rel = i.next();
  if (rel.parentVar(v) != null)
    return true;
}haha 
for (Iterator<PptRelation> i = children.iterator() ; i.hasNext() ;)
{
  PptRelation rel = i.next();
  if (!rel.child.in_merge)
    rel.child.mergeInvs();
}haha 
for (Iterator<PptRelation> i = children.iterator() ; i.hasNext() ;)
{
  PptRelation rel = i.next();
  rel.child.remove_child_invs(rel);
}haha 
for (Iterator<PptRelation> i = children.iterator() ; i.hasNext() ;)
{
  PptRelation rel = i.next();
  rel.child.parents.remove(rel);
}haha 
for (Iterator<PptConditional> ii = cond_iterator() ; ii.hasNext() ;)
{
  PptConditional ppt_cond = ii.next();
  if (debugConditional.isLoggable(Level.FINE))
  {
    debugConditional.fine(("Merge invariants for conditional " + ppt_cond.name()));
    for (int jj = 0 ; jj < ppt_cond.children.size() ; jj++)
    {
      PptRelation rel = ppt_cond.children.get(jj);
      debugConditional.fine(("child relation: " + rel));
      debugConditional.fine(("child equality set = " + rel.child.equality_sets_txt()));
    }
  }
  ppt_cond.mergeInvs();
  debugConditional.fine(("After merge, equality set = " + ppt_cond.equality_sets_txt()));
}haha 
for (Iterator<PptRelation> i = children.iterator() ; i.hasNext() ;)
{
  PptRelation crel = i.next();
  if (!crel.child.invariants_removed)
  {
    return;
  }
}haha 
for (Iterator<PptSlice> i = slices_to_remove.iterator() ; i.hasNext() ;)
{
  PptSlice slice = i.next();
  removeSlice(slice);
}haha 
for (Iterator<PptSlice> j = ppt.views_iterator() ; j.hasNext() ;)
{
  PptSlice slice = j.next();
  for (int k = 0 ; k < slice.invs.size() ; k++)
  {
    Invariant inv = slice.invs.get(k);
    String falsify = "";
    if (inv.is_false())
      falsify = "(falsified) ";
    log.fine((" : " + falsify + inv.format()));
  }
}haha 
28
/Users/remywang/daikon//java/daikon/tools/ExtractConsequent.java
for (Iterator<PptTopLevel> itor = ppts_sorted.iterator() ; itor.hasNext() ;)
{
  PptTopLevel ppt = itor.next();
  extract_consequent_maybe(ppt, ppts);
}haha 
1
/Users/remywang/daikon//java/daikon/tools/InvMatch.java
for (Iterator<InvTranslate> j = current_translation.iterator() ; j.hasNext() ;)
{
  InvTranslate xlate = j.next();
  Fmt.pf("    %s", xlate);
}haha 
for (Iterator<InvTranslate> i = best_translation.iterator() ; i.hasNext() ;)
{
  InvTranslate xlate = i.next();
  Fmt.pf("  %s", xlate);
}haha 
for (Iterator<InvTranslate> j = inv_xlate_list.iterator() ; j.hasNext() ;)
{
  InvTranslate xlate = j.next();
  Fmt.pf("  %s", xlate);
}haha 
for (Iterator<InvTranslate> i = translation_list.iterator() ; i.hasNext() ;)
{
  InvTranslate xlate = i.next();
  if (xlate == null)
    continue;
  for (String key : xlate.var_map.keySet()) {
                                              String val = xlate.var_map.get(key);
                                              String cur_val = var_map.get(key);
                                              if (cur_val == null)
                                                var_map.put(key, val);
                                              else
                                                if (!cur_val.equals(val))
                                                  return false;
                                            }
}haha 
for (Iterator<InvTranslate> j = current_translation.iterator() ; j.hasNext() ;)
{
  InvTranslate xlate = j.next();
  if (xlate != null)
    quality += xlate.quality;
}haha 
5
/Users/remywang/daikon//java/daikon/tools/InvTranslate.java
0
/Users/remywang/daikon//java/daikon/tools/runtimechecker/InstrumentVisitor.java
for (Iterator<Invariant> invI = invList.iterator() ; invI.hasNext() ;)
{
  Invariant inv = invI.next();
  xmlStringToIndex.put(toProperty(inv).xmlString(), Integer.toString(varNumCounter));
  varNumCounter++;
}haha 
for (Iterator<FormalParameter> i = Ast.getParametersNoImplicit(ctor).iterator() ; i.hasNext() ;)
{
  FormalParameter param = i.next();
  parameters.add(Ast.getName(param));
  typesAndParameters.add(Ast.format(param));
}haha 
for (Iterator<FormalParameter> i = Ast.getParameters(method).iterator() ; i.hasNext() ;)
{
  FormalParameter param = i.next();
  parameters.add(Ast.getName(param));
  typesAndParameters.add(Ast.format(param));
}haha 
for (Iterator<Invariant> i = invariants.iterator() ; i.hasNext() ;)
{
  Invariant inv = i.next();
  if (!inv.isValidExpression(OutputFormat.JAVA))
  {
    continue;
  }
  if (inv instanceof FunctionBinary)
  {
    FunctionBinary fb = (FunctionBinary) inv;
    if (fb.isLshift() || fb.isRshiftSigned() || fb.isRshiftUnsigned())
    {
      continue;
    }
  }
  if (outputOnlyHighConfInvariants)
  {
    if (toProperty(inv).calculateConfidence() < 0.5)
    {
      continue;
    }
  }
  survivors.add(inv);
}haha 
for (Iterator<PptTopLevel> i = matching_ppts.iterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (ppt.ppt_name.isExitPoint() && ppt.ppt_name.isCombinedExitPoint())
  {
    List<Invariant> postconditions = filterInvariants(Ast.getInvariants(ppt, pptmap));
    appendInvariantChecks(postconditions, code, "daikon.tools.runtimechecker.Violation.Time.onExit");
  }
}haha 
for (Iterator<PptTopLevel> i = matching_ppts.iterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (ppt.ppt_name.isEnterPoint())
  {
    List<Invariant> preconditions = filterInvariants(Ast.getInvariants(ppt, pptmap));
    appendInvariantChecks(preconditions, code, "daikon.tools.runtimechecker.Violation.Time.onEntry");
  }
}haha 
for (Iterator<PptTopLevel> i = matching_ppts.iterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (ppt.ppt_name.isEnterPoint())
  {
    List<Invariant> preconditions = filterInvariants(Ast.getInvariants(ppt, pptmap));
    List<InvProp> finalList = null;
    if (majorProperties)
    {
      finalList = getMajor(preconditions);
    }
    else
    {
      finalList = getMinor(preconditions);
    }
    appendInvariantChecks_checker(finalList, code);
  }
}haha 
for (Iterator<PptTopLevel> i = matching_ppts.iterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (ppt.ppt_name.isExitPoint() && ppt.ppt_name.isCombinedExitPoint())
  {
    List<Invariant> postconditions = filterInvariants(Ast.getInvariants(ppt, pptmap));
    List<InvProp> finalList = null;
    if (majorProperties)
    {
      finalList = getMajor(postconditions);
    }
    else
    {
      finalList = getMinor(postconditions);
    }
    appendInvariantChecks_checker(finalList, code);
  }
}haha 
for (Iterator<PptTopLevel> i = matching_ppts.iterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (ppt.ppt_name.isEnterPoint())
  {
    List<Invariant> preconditions = filterInvariants(Ast.getInvariants(ppt, pptmap));
    List<InvProp> finalList = null;
    if (majorProperties)
    {
      finalList = getMajor(preconditions);
    }
    else
    {
      finalList = getMinor(preconditions);
    }
    appendInvariantChecks_checker(finalList, code);
  }
}haha 
for (Iterator<PptTopLevel> i = matching_ppts.iterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (ppt.ppt_name.isExitPoint() && ppt.ppt_name.isCombinedExitPoint())
  {
    List<Invariant> postconditions = filterInvariants(Ast.getInvariants(ppt, pptmap));
    List<InvProp> finalList = null;
    if (majorProperties)
    {
      finalList = getMajor(postconditions);
    }
    else
    {
      finalList = getMinor(postconditions);
    }
    appendInvariantChecks_checker(finalList, code);
  }
}haha 
10
/Users/remywang/daikon//java/daikon/tools/jtb/InstrumentObserversVisitor.java
for (Iterator<FormalParameter> i = Ast.getParameters(method).iterator() ; i.hasNext() ;)
{
  FormalParameter param = i.next();
  parameters.add(Ast.getName(param));
}haha 
1
/Users/remywang/daikon//java/daikon/tools/jtb/CreateSpinfoC.java
0
/Users/remywang/daikon//java/daikon/tools/jtb/Annotation.java
0
/Users/remywang/daikon//java/daikon/tools/compare/LogicalCompare.java
0
/Users/remywang/daikon//java/daikon/tools/InvariantChecker.java
for (Iterator<PptSlice> i = ppt.views_iterator() ; i.hasNext() ;)
{
  PptSlice slice = i.next();
  if (debug_detail.isLoggable(Level.FINE))
    debug_detail.fine((": processing slice " + slice + "vars: " + Debug.toString(slice.var_infos, vt)));
  for (int j = 0 ; j < slice.var_infos.length ; j++)
  {
    VarInfo v = slice.var_infos[j];
    int mod = vt.getModified(v);
    if (v.isMissing(vt))
    {
      if (debug_detail.isLoggable(Level.FINE))
        debug_detail.fine((": : Skipping slice, " + v.name.name() + " missing"));
      continue slice_loop;
    }
    if (v.missingOutOfBounds())
    {
      if (debug_detail.isLoggable(Level.FINE))
        debug.fine((": : Skipping slice, " + v.name.name() + " out of bounds"));
      continue slice_loop;
    }
  }
  for (Iterator<Invariant> j = slice.invs.iterator() ; j.hasNext() ;)
  {
    Invariant inv = j.next();
    if (debug_detail.isLoggable(Level.FINE))
      debug_detail.fine((": : Processing invariant: " + inv));
    if (!inv.isActive())
    {
      if (debug_detail.isLoggable(Level.FINE))
        debug_detail.fine((": : skipped non-active " + inv));
      continue;
    }
    Invariant pre_inv = (Invariant) inv.clone();
    InvariantStatus status = inv.add_sample(vt, 1);
    if (status != InvariantStatus.NO_CHANGE)
    {
      LineNumberReader lnr = FileIO.data_trace_state.reader;
      String line = lnr == null ? "?" : String.valueOf(lnr.getLineNumber());
      output_stream.println(("At ppt " + ppt.name + ", Invariant '" + pre_inv.format() + "' invalidated by sample " + Debug.toString(slice.var_infos, vt) + "at line " + line));
      error_cnt++;
    }
  }
}haha 
1
/Users/remywang/daikon//java/daikon/test/SampleTester.java
for (Iterator<Invariant> i = slice.invs.iterator() ; i.hasNext() ;)
{
  Invariant inv = i.next();
  if (inv.getClass() == cls)
    return true;
  if (format != null && format.equals(inv.format()))
    return true;
  debug.fine(Fmt.spf("trace %s: '%s'", inv.getClass(), inv.format()));
}haha 
for (Iterator<Invariant> i = slice.invs.iterator() ; i.hasNext() ;)
{
  Invariant inv = i.next();
  Fmt.pf("found %s: %s", inv.getClass(), inv.format());
}haha 
2
/Users/remywang/daikon//java/daikon/diff/MatchCountVisitor2.java
for (Iterator<String> i = cnt.iterator() ; i.hasNext() ;)
{
  String elem = i.next();
  if (targSet.contains(elem))
    correctSet.add(elem);
}haha 
for (Iterator<String> i = targSet.iterator() ; i.hasNext() ;)
{
  String str = i.next();
  if (correctSet.contains(str))
  {
    System.out.println(str);
  }
}haha 
for (Iterator<String> i = targSet.iterator() ; i.hasNext() ;)
{
  String str = i.next();
  if (!correctSet.contains(str))
  {
    System.out.println(str);
  }
}haha 
for (Iterator<String> i = cnt.iterator() ; i.hasNext() ;)
{
  String str = i.next();
  if (!correctSet.contains(str))
  {
    System.out.println(str);
  }
}haha 
4
/Users/remywang/daikon//java/daikon/diff/MultiDiff.java
0
/Users/remywang/daikon//java/daikon/diff/PptCountVisitor.java
for (Iterator<String> i = targSet.iterator() ; i.hasNext() ;)
{
  String str = i.next();
  if (correctSet.contains(str))
  {
    System.out.println(str);
  }
}haha 
for (Iterator<String> i = targSet.iterator() ; i.hasNext() ;)
{
  String str = i.next();
  if (!correctSet.contains(str))
  {
    System.out.println(str);
  }
}haha 
for (Iterator<String> i = incorrectSet.iterator() ; i.hasNext() ;)
{
  String str = i.next();
  System.out.println(str);
}haha 
3
/Users/remywang/daikon//java/daikon/diff/InvMap.java
for (Iterator<Invariant> i2 = invs.iterator() ; i2.hasNext() ;)
{
  Invariant inv = i2.next();
  result += "  " + inv.format() + Global.lineSep;
}haha 
1
/Users/remywang/daikon//java/daikon/diff/ConsequentExtractorVisitor.java
for (Iterator<InvNode> i = node.children() ; i.hasNext() ;)
{
  InvNode child = i.next();
  if (child.getInv1() != null)
  {
    child.getInv1().ppt.invs.clear();
  }
}haha 
1
/Users/remywang/daikon//java/daikon/diff/Diff.java
for (Iterator<Invariant> j = invs1.iterator() ; j.hasNext() ;)
{
  Invariant inv = j.next();
  if (inv instanceof Implication)
  {
    Implication imp = (Implication) inv;
    if (!repeatFilter.contains(imp.consequent().format_using(OutputFormat.JAVA)))
    {
      repeatFilter.add(imp.consequent().format_using(OutputFormat.JAVA));
      ret.add(imp.consequent());
    }
    if (imp.iff == true)
    {
      if (!repeatFilter.contains(imp.predicate().format()))
      {
        repeatFilter.add(imp.predicate().format());
        ret.add(imp.predicate());
      }
    }
  }
  else
  {
    ret.add(inv);
  }
}haha 
for (Iterator<String> i = manip.nameStringSet().iterator() ; i.hasNext() ;)
{
  String somePptName = i.next();
  if (targ.equals(somePptName))
  {
    PptTopLevel repl = manip.get(somePptName);
    return repl.getInvariants();
  }
}haha 
for (Iterator<String> i = manip.nameStringSet().iterator() ; i.hasNext() ;)
{
  String somePptName = i.next();
  if (targetName.equals(somePptName))
  {
    PptTopLevel repl = manip.get(somePptName);
    return UtilMDE.sortList(repl.getInvariants(), PptTopLevel.icfp);
  }
}haha 
3
/Users/remywang/daikon//java/daikon/diff/MultiDiffVisitor.java
for (Iterator<String> i = programPointsList.iterator() ; i.hasNext() ;)
{
  String key = i.next();
  lastMap.put(key, new ArrayList<String>());
}haha 
for (Iterator<String> i = programPointsList.iterator() ; i.hasNext() ;)
{
  String key = i.next();
  lastMap.put(key, new ArrayList<String>());
}haha 
2
/Users/remywang/daikon//java/daikon/diff/ConsequentCVFSortComparator.java
0
/Users/remywang/daikon//java/daikon/diff/ConsequentSortComparator.java
0
/Users/remywang/daikon//java/daikon/FileIO.java
for (Iterator<Invocation> i = invocations.iterator() ; i.hasNext() ;)
{
  Invocation invok = i.next();
  System.out.println(invok.format());
}haha 
for (Iterator<Invocation> i = invocations.iterator() ; i.hasNext() ;)
{
  Invocation invok = i.next();
  invok = invok.canonicalize();
  if (counter.containsKey(invok))
  {
    Integer oldCount = counter.get(invok);
    Integer newCount = new Integer(oldCount.intValue() + 1);
    counter.put(invok, newCount);
  }
  else
  {
    counter.put(invok, new Integer(1));
  }
}haha 
2
/Users/remywang/daikon//java/daikon/PptName.java
0
/Users/remywang/daikon//java/daikon/DiscReasonMap.java
0
/Users/remywang/daikon//java/daikon/PrintInvariants.java
for (Iterator<PptTopLevel> i = ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel my_ppt = i.next();
  if (my_ppt.parents.size() == 0)
    my_ppt.debug_print_tree(debug, 0, null);
}haha 
for (Iterator<PptConditional> i = ppt.cond_iterator() ; i.hasNext() ;)
{
  PptConditional pcond = i.next();
  sb.append(print_reasons_from_ppt(pcond, ppts));
}haha 
for (Iterator<PptConditional> j = ppt.cond_iterator() ; j.hasNext() ;)
{
  PptConditional pcond = j.next();
  print_invariants_maybe(pcond, out, all_ppts);
}haha 
for (Iterator<Invariant> ii = ppt.joiner_view.invs.iterator() ; ii.hasNext() ;)
{
  Invariant inv = ii.next();
  PptSplitter.debug.fine(("-- " + inv.format()));
}haha 
for (Iterator<PptSlice> si = ppt.views_iterator() ; si.hasNext() ;)
{
  PptSlice slice = si.next();
  total_slice_cnt++;
  total_inv_cnt += slice.invs.size();
  if (slice.arity() != 3)
    continue;
  slice_cnt++;
  inv_cnt += slice.invs.size();
  for (Iterator<Invariant> ii = slice.invs.iterator() ; ii.hasNext() ;)
  {
    Invariant inv = ii.next();
    if (inv.getClass().getName().indexOf("Ternary") > 0)
    {
      lt_cnt++;
    }
  }
}haha 
for (Iterator<Invariant> ii = slice.invs.iterator() ; ii.hasNext() ;)
{
  Invariant inv = ii.next();
  if (inv.getClass().getName().indexOf("Ternary") > 0)
  {
    lt_cnt++;
  }
}haha 
for (Iterator<Invariant> ii = slice.invs.iterator() ; ii.hasNext() ;)
{
  Invariant inv = ii.next();
  Fmt.pf("%s%s [%s]", indent, inv.format(), UtilMDE.unqualified_name(inv.getClass()));
}haha 
for (Iterator<PptTopLevel> i = ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  inv_cnt += ppt.invariant_cnt();
}haha 
for (Iterator<PptTopLevel> i = ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  NIS.create_suppressed_invs(ppt);
}haha 
for (Iterator<PptTopLevel> i = ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  inv_cnt += ppt.invariant_cnt();
}haha 
10
/Users/remywang/daikon//java/daikon/Daikon.java
for (Iterator<PptTopLevel> itor = all_ppts.ppt_all_iterator() ; itor.hasNext() ;)
{
  PptTopLevel ppt = itor.next();
  PrintInvariants.print_filter_stats(debugStats, ppt, all_ppts);
}haha 
for (Iterator<PptTopLevel> i = all_ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (ppt.parents.size() == 0)
  {
    ppt.mergeInvs();
  }
}haha 
for (Iterator<PptConditional> ii = ppt.cond_iterator() ; ii.hasNext() ;)
{
  PptConditional ppt_cond = ii.next();
  init_ppt(ppt_cond, all_ppts);
}haha 
for (Iterator<PptTopLevel> i = exit_ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  ppts.add(ppt);
}haha 
for (Iterator<PptTopLevel> itor = all_ppts.ppt_all_iterator() ; itor.hasNext() ;)
{
  PptTopLevel ppt = itor.next();
  if (ppt.constants != null)
    ppt.constants.post_process();
}haha 
for (Iterator<PptTopLevel> itor = all_ppts.ppt_all_iterator() ; itor.hasNext() ;)
{
  PptTopLevel ppt = itor.next();
  ppt.postProcessEquality();
}haha 
for (Iterator<PptTopLevel> itor = all_ppts.ppt_all_iterator() ; itor.hasNext() ;)
{
  PptTopLevel ppt = itor.next();
  debugEquality.fine((ppt.name() + ": " + ppt.equality_sets_txt()));
}haha 
for (Iterator<PptTopLevel> itor = all_ppts.pptIterator() ; itor.hasNext() ;)
{
  PptTopLevel ppt = itor.next();
  ppt.addImplications();
}haha 
for (Iterator<PptTopLevel> itor = all_ppts.ppt_all_iterator() ; itor.hasNext() ;)
{
  PptTopLevel ppt = itor.next();
  ppt.mark_implied_via_simplify(all_ppts);
  System.out.print(".");
  System.out.flush();
}haha 
9
/Users/remywang/daikon//java/daikon/VarInfo.java
for (Iterator<VarInfoName> i = name.inOrderTraversal().iterator() ; i.hasNext() ;)
{
  VarInfoName next = i.next();
  if (next instanceof VarInfoName.Elements)
  {
    VarInfoName.Elements elems = (VarInfoName.Elements) next;
    VarInfo seq = ppt.findVar(elems.term);
    if (!seq.type.isArray())
    {
      return false;
    }
  }
}haha 
1
/Users/remywang/daikon//java/daikon/LogHelper.java
0
/Users/remywang/daikon//java/daikon/suppress/NISuppression.java
for (Iterator<Invariant> j = a.iterator() ; j.hasNext() ;)
{
  Invariant inv = j.next();
  if (inv.is_false())
    false_cnt++;
}haha 
for (Iterator<Invariant> j = antecedents[i].iterator() ; j.hasNext() ;)
{
  Invariant inv = j.next();
  out += "    " + inv.format() + (inv.is_false() ? " [false]" : " t") + sep;
}haha 
2
/Users/remywang/daikon//java/daikon/suppress/NISuppressionSet.java
for (Iterator<Invariant> i = new_invs.iterator() ; i.hasNext() ;)
{
  Invariant new_inv = i.next();
  if (new_inv.getClass() == inv.getClass() && new_inv.ppt == slice)
    Assert.assertTrue(false, Fmt.spf(("inv %s:%s already in new_invs " + "(slice %s)"), inv.getClass(), inv.format(), slice));
}haha 
1
/Users/remywang/daikon//java/daikon/suppress/NIS.java
for (Iterator<NISuppressionSet> i = all_suppressions.iterator() ; i.hasNext() ;)
{
  NISuppressionSet suppression_set = i.next();
  suppression_set.add_to_suppressor_map(suppressor_map);
}haha 
for (Iterator<NISuppressionSet> k = suppressor_ss_list.iterator() ; k.hasNext() ;)
{
  NISuppressionSet suppressor_ss = k.next();
  suppressor_ss.recurse_definitions(ss);
}haha 
for (Iterator<NISuppressionSet> i = ss_list.iterator() ; i.hasNext() ;)
{
  NISuppressionSet ss = i.next();
  ss.clear_state();
  if (debug.isLoggable(Level.FINE))
    debug.fine(("processing suppression set " + ss + " over falsified inv " + inv.format()));
  ss.falsified(inv, new_invs);
  suppressions_processed += ss.suppression_set.length;
}haha 
for (Iterator<Invariant> i = ppt.invariants_iterator() ; i.hasNext() ;)
{
  Invariant inv = i.next();
  if (inv.is_false())
    false_cnt++;
  inv_cnt++;
}haha 
for (Iterator<Antecedents> i = comp_ants.values().iterator() ; i.hasNext() ;)
{
  Antecedents ants = i.next();
  debugAnt.fine(ants.toString());
}haha 
for (Iterator<Antecedents> i = comp_ants.values().iterator() ; i.hasNext() ;)
{
  Antecedents ants = i.next();
  debugAnt.fine(ants.toString());
}haha 
for (Iterator<NISuppressionSet> i = all_suppressions.iterator() ; i.hasNext() ;)
{
  NISuppressionSet ss = i.next();
  for (Iterator<NISuppression> j = ss.iterator() ; j.hasNext() ;)
  {
    NISuppression sup = j.next();
    suppressions_processed++;
    for (Iterator<Antecedents> k = comp_ants.values().iterator() ; k.hasNext() ;)
    {
      Antecedents ants = k.next();
      sup.find_unsuppressed_invs(unsuppressed_invs, ants);
    }
  }
}haha 
for (Iterator<NISuppression> j = ss.iterator() ; j.hasNext() ;)
{
  NISuppression sup = j.next();
  suppressions_processed++;
  for (Iterator<Antecedents> k = comp_ants.values().iterator() ; k.hasNext() ;)
  {
    Antecedents ants = k.next();
    sup.find_unsuppressed_invs(unsuppressed_invs, ants);
  }
}haha 
for (Iterator<Antecedents> k = comp_ants.values().iterator() ; k.hasNext() ;)
{
  Antecedents ants = k.next();
  sup.find_unsuppressed_invs(unsuppressed_invs, ants);
}haha 
for (Iterator<Antecedents> i = comp_ants.values().iterator() ; i.hasNext() ;)
{
  Antecedents ants = i.next();
  if (ants.alwaysComparable())
    continue;
  ants.add(compare_all);
}haha 
for (Iterator<NISuppressionSet> i = all_suppressions.iterator() ; i.hasNext() ;)
{
  NISuppressionSet ss = i.next();
  for (Iterator<NISuppression> j = ss.iterator() ; j.hasNext() ;)
  {
    NISuppression sup = j.next();
    for (Iterator<Antecedents> k = comp_ants.values().iterator() ; k.hasNext() ;)
    {
      Antecedents ants = k.next();
      sup.find_suppressed_invs(suppressed_invs, ants);
    }
  }
}haha 
for (Iterator<NISuppression> j = ss.iterator() ; j.hasNext() ;)
{
  NISuppression sup = j.next();
  for (Iterator<Antecedents> k = comp_ants.values().iterator() ; k.hasNext() ;)
  {
    Antecedents ants = k.next();
    sup.find_suppressed_invs(suppressed_invs, ants);
  }
}haha 
for (Iterator<Antecedents> k = comp_ants.values().iterator() ; k.hasNext() ;)
{
  Antecedents ants = k.next();
  sup.find_suppressed_invs(suppressed_invs, ants);
}haha 
for (Iterator<PptSlice> i = slice_iterator ; i.hasNext() ;)
{
  PptSlice slice = i.next();
  for (Iterator<Invariant> j = slice.invs.iterator() ; j.hasNext() ;)
  {
    Invariant inv = j.next();
    if (!is_suppressor(inv.getClass()))
      continue;
    if (inv.is_false())
      false_invs++;
    VarComparability vc = inv.get_comparability();
    Antecedents ants = comp_ants.get(vc);
    if (ants == null)
    {
      ants = new Antecedents(vc);
      comp_ants.put(vc, ants);
    }
    ants.add(inv);
  }
}haha 
for (Iterator<PptSlice> i = ppt.views_iterator() ; i.hasNext() ;)
{
  PptSlice slice = i.next();
  for (Iterator<Invariant> j = slice.invs.iterator() ; j.hasNext() ;)
  {
    Invariant inv = j.next();
    if (inv.is_ni_suppressed())
    {
      inv.log(("Removed because suppressed " + inv.format()));
      j.remove();
    }
  }
}haha 
for (Iterator<Invariant> j = invs.iterator() ; j.hasNext() ;)
{
  Invariant inv = j.next();
  add(inv);
}haha 
for (Iterator<Invariant> j = ilist.iterator() ; j.hasNext() ;)
{
  Invariant inv = j.next();
  if (inv.is_false())
    out += inv.format() + "[FALSE] ";
  else
    out += inv.format() + " ";
}haha 
17
/Users/remywang/daikon//java/daikon/suppress/NISuppressor.java
for (Iterator<Invariant> i = slice.invs.iterator() ; i.hasNext() ;)
{
  Invariant slice_inv = i.next();
  if (match_true(slice_inv))
    return state = NIS.VALID;
}haha 
for (Iterator<Invariant> i = slice.invs.iterator() ; i.hasNext() ;)
{
  Invariant slice_inv = i.next();
  if (match_true(slice_inv))
  {
    if (NIS.debug.isLoggable(Level.FINE))
      NIS.debug.fine(("suppressor matches inv " + slice_inv.format() + " " + !slice_inv.is_false()));
    return state = NIS.VALID;
  }
}haha 
2
/Users/remywang/daikon//java/daikon/suppress/NISuppressee.java
0
/Users/remywang/daikon//java/daikon/VarComparabilityNone.java
0
/Users/remywang/daikon//java/daikon/Ppt.java
0
/Users/remywang/daikon//java/daikon/PptSplitter.java
for (OrderedPairIterator<Invariant> opi = new OrderedPairIterator<Invariant>(ss1.iterator(), ss2.iterator(), icfp) ; opi.hasNext() ;)
{
  Pair pair = opi.next();
  if (pair.a != null && pair.b != null)
  {
    Invariant inv1 = (Invariant) pair.a;
    Invariant inv2 = (Invariant) pair.b;
    result.add(inv1);
  }
}haha 
1
/Users/remywang/daikon//java/daikon/gui/treeGUI/InvariantTableModel.java
for (Iterator<Invariant> iter = allInvariants.iterator() ; iter.hasNext() ;)
{
  Invariant invariant = iter.next();
  if (invariantFilters.shouldKeep(invariant) == null)
    filteredInvariants.add(invariant);
}haha 
1
/Users/remywang/daikon//java/daikon/DaikonSimple.java
for (Iterator<VarInfo> j = ppt.var_info_iterator() ; j.hasNext() ;)
{
  VarInfo var2 = j.next();
  if (var.name.equals(var2.name))
  {
    values[k] = vt.getValue(var2);
    mods[k] = vt.getModified(var2);
    found = true;
    break;
  }
}haha 
1
/Users/remywang/daikon//java/daikon/VarInfoName.java
for (Iterator<VarInfoName> i = o.args.iterator() ; i.hasNext() ;)
{
  VarInfoName vin = i.next();
  retval = vin.accept(this);
  if (retval != null)
    return retval;
}haha 
for (Iterator<VarInfoName> i = o.args.iterator() ; i.hasNext() ;)
{
  VarInfoName vin = i.next();
  result = vin.accept(this);
  if (result != null)
    return result;
}haha 
for (Iterator<VarInfoName> i = o.args.iterator() ; i.hasNext() ;)
{
  VarInfoName vin = i.next();
  retval = vin.accept(this);
  if (retval != null)
    return retval;
}haha 
3
/Users/remywang/daikon//java/daikon/Debug.java
for (Iterator<PptTopLevel> i = all_ppts.ppt_all_iterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  for (Iterator<PptSlice> j = ppt.views_iterator() ; j.hasNext() ;)
  {
    PptSlice slice = j.next();
    for (int k = 0 ; k < slice.invs.size() ; k++)
    {
      Invariant inv = slice.invs.get(k);
      if (inv.log((msg + ": found #" + k + "= " + inv.format() + " in slice " + slice)))
        found = true;
    }
  }
}haha 
for (Iterator<PptSlice> j = ppt.views_iterator() ; j.hasNext() ;)
{
  PptSlice slice = j.next();
  for (int k = 0 ; k < slice.invs.size() ; k++)
  {
    Invariant inv = slice.invs.get(k);
    if (inv.log((msg + ": found #" + k + "= " + inv.format() + " in slice " + slice)))
      found = true;
  }
}haha 
2
/Users/remywang/daikon//java/daikon/UnionInvariants.java
for (Iterator<PptTopLevel> i = result.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  ppt.mark_implied_via_simplify(result);
}haha 
for (Iterator<PptTopLevel> i = source.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (ppt.numViews() == 0 && ppt.joiner_view.invs.size() == 0)
    continue;
  if (collector.get(ppt.ppt_name) != null)
  {
    throw new RuntimeException("Cannot merge two non-empty ppts named " + ppt.name());
  }
  System.out.println(("Adding ppt " + ppt.name()));
  collector.add(ppt);
}haha 
2
/Users/remywang/daikon//java/daikon/PptMap.java
for (Iterator<PptTopLevel> iPpt = ppts.iterator() ; iPpt.hasNext() ;)
{
  PptTopLevel ppt = iPpt.next();
  add(ppt);
}haha 
for (Iterator<PptTopLevel> i = nameToPpt.values().iterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  ppt.trimToSize();
}haha 
for (Iterator<PptTopLevel> i = this.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  ppt.repCheck();
}haha 
for (Iterator<PptTopLevel> i = this.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  result += ppt.numViews();
}haha 
4
/Users/remywang/daikon//java/daikon/MergeInvariants.java
for (Iterator<PptTopLevel> i = merge_ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  ppt.clean_for_merge();
}haha 
for (Iterator<PptTopLevel> i = merge_ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (!ppt.ppt_name.isExitPoint())
    continue;
  if (ppt.ppt_name.isCombinedExitPoint())
    continue;
  for (Iterator<PptRelation> j = ppt.children.iterator() ; j.hasNext() ;)
  {
    PptRelation rel = j.next();
    if (rel.getRelationType() == PptRelation.PPT_PPTCOND)
      j.remove();
  }
  for (int j = 0 ; j < pptmaps.size() ; j++)
  {
    PptMap pmap = pptmaps.get(j);
    PptTopLevel child = pmap.get(ppt.ppt_name);
    if (decl_file == null && child == null)
      throw new Error("Can't find " + ppt.ppt_name + " in " + inv_files.get(j));
    if (child == null)
      continue;
    if (child.num_samples() == 0)
      continue;
    if (child.equality_view == null)
      System.out.println(("equality_view == null in child ppt: " + child.name() + " (" + inv_files.get(j) + ")"));
    else
      if (child.equality_view.invs == null)
        System.out.println(("equality_view.invs == null in child ppt: " + child.name() + " (" + inv_files.get(j) + ")" + " samples = " + child.num_samples()));
    PptRelation rel = PptRelation.newMergeChildRel(ppt, child);
    setup_conditional_merge(rel, ppt, child);
  }
}haha 
for (Iterator<PptTopLevel> i = merge_ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (ppt.parents.size() == 0)
    ppt.debug_print_tree(debug, 0, null);
}haha 
for (Iterator<PptTopLevel> itor = merge_ppts.pptIterator() ; itor.hasNext() ;)
{
  PptTopLevel ppt = itor.next();
  ppt.postProcessEquality();
}haha 
for (Iterator<PptTopLevel> itor = merge_ppts.pptIterator() ; itor.hasNext() ;)
{
  PptTopLevel ppt = itor.next();
  if (ppt.num_samples() > 0)
    ppt.addImplications();
}haha 
for (Iterator<PptTopLevel> i = merge_ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (!ppt.ppt_name.isExitPoint())
    continue;
  if (ppt.ppt_name.isCombinedExitPoint())
    continue;
  ppt.children.clear();
  for (Iterator<PptConditional> conds = ppt.cond_iterator() ; conds.hasNext() ;)
  {
    PptConditional cond = conds.next();
    cond.children.clear();
  }
}haha 
for (Iterator<PptConditional> conds = ppt.cond_iterator() ; conds.hasNext() ;)
{
  PptConditional cond = conds.next();
  cond.children.clear();
}haha 
7
/Users/remywang/daikon//java/daikon/Runtime.java
0
/Users/remywang/daikon//java/daikon/PptRelation.java
for (Iterator<PptTopLevel> pi = all_ppts.pptIterator() ; pi.hasNext() ;)
{
  PptTopLevel ppt = pi.next();
  if (ppt.ppt_name.isNumberedExitPoint())
    continue;
  if (!ppt.has_splitters())
    continue;
  splitter_loop: for (Iterator<PptSplitter> ii = ppt.splitters.iterator() ; ii.hasNext() ;)
                 {
                   PptSplitter ppt_split = ii.next();
                   List<SplitChild> split_children = new ArrayList<SplitChild>();
                   child_loop: for (int jj = 0 ; jj < ppt.children.size() ; jj++)
                               {
                                 PptRelation rel = ppt.children.get(jj);
                                 if (!rel.child.has_splitters())
                                   break;
                                 for (Iterator<PptSplitter> kk = rel.child.splitters.iterator() ; kk.hasNext() ;)
                                 {
                                   PptSplitter csplit = kk.next();
                                   if (ppt_split.splitter == csplit.splitter)
                                   {
                                     split_children.add(new SplitChild(rel, csplit));
                                     continue child_loop;
                                   }
                                 }
                                 break;
                               }
                   if (split_children.size() != ppt.children.size())
                   {
                     ii.remove();
                     continue;
                   }
                   for (Iterator<SplitChild> jj = split_children.iterator() ; jj.hasNext() ;)
                   {
                     SplitChild sc = jj.next();
                     ppt_split.add_relation(sc.rel, sc.ppt_split);
                   }
                 }
}haha 
for (Iterator<PptSplitter> kk = rel.child.splitters.iterator() ; kk.hasNext() ;)
{
  PptSplitter csplit = kk.next();
  if (ppt_split.splitter == csplit.splitter)
  {
    split_children.add(new SplitChild(rel, csplit));
    continue child_loop;
  }
}haha 
for (Iterator<SplitChild> jj = split_children.iterator() ; jj.hasNext() ;)
{
  SplitChild sc = jj.next();
  ppt_split.add_relation(sc.rel, sc.ppt_split);
}haha 
for (Iterator<PptTopLevel> i = all_ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  if (ppt.parents.size() == 0)
    ppt.debug_print_tree(debug, 0, null);
}haha 
for (Iterator<PptTopLevel> i = all_ppts.pptIterator() ; i.hasNext() ;)
{
  PptTopLevel ppt = i.next();
  debug.fine((ppt.name() + " equality sets: " + ppt.equality_sets_txt()));
}haha 
5
/Users/remywang/daikon//java/daikon/ValueTuple.java
0
/Users/remywang/daikon//java/daikon/PptSlice.java
for (Iterator<Invariant> overInvs = invs.iterator() ; overInvs.hasNext() ;)
{
  Invariant inv = overInvs.next();
  if (omitTypes['r'] && inv.isReflexive())
    toRemove.add(inv);
}haha 
for (Iterator<Invariant> i = invs.iterator() ; i.hasNext() ;)
{
  Invariant inv = i.next();
  inv.repCheck();
  Assert.assertTrue((inv.ppt == this));
}haha 
for (Iterator<Invariant> i = invs.iterator() ; i.hasNext() ;)
{
  Invariant mine = i.next();
  if (mine.match(inv))
    return true;
}haha 
for (Iterator<Invariant> i = invs.iterator() ; i.hasNext() ;)
{
  Invariant mine = i.next();
  if (mine.getClass() == inv.getClass() && mine.isSameFormula(inv))
    return mine;
}haha 
for (Iterator<Invariant> i = invs.iterator() ; i.hasNext() ;)
{
  Invariant inv = i.next();
  if (inv.getClass() == cls)
    return inv;
}haha 
5
/Users/remywang/daikon//java/daikon/ModBitTracker.java
0
/Users/remywang/daikon//java/daikon/PptSliceEquality.java
for (Iterator<Equality> iNewInvs = newInvs.iterator() ; iNewInvs.hasNext() ;)
{
  Equality eq = iNewInvs.next();
  if (parent.constants == null || !parent.constants.is_missing(eq.leader()))
    newInvsLeaders.add(eq.leader());
}haha 
for (Iterator<VarInfo> i = vis.iterator() ; i.hasNext() ;)
{
  VarInfo vi = i.next();
  if (vi.missingOutOfBounds())
    out_of_bounds.add(vi);
  else
    if (vt.isMissing(vi))
    {
      addToBindingList(multiMap, dummyMissing, vi);
    }
    else
    {
      if (vi.getValue(vt) == null)
      {
        Fmt.pf("null value for variable %s, mod=%s at ppt %s", vi.name.name(), ("" + vt.getModified(vi)), parent.name());
        VarInfo rv = parent.find_var_by_name("return");
        Fmt.pf(("return value = " + Debug.toString(rv.getValue(vt))));
        Fmt.pf(("At line number " + FileIO.data_trace_state.reader.getLineNumber()));
      }
      addToBindingList(multiMap, vi.getValue(vt), vi);
    }
}haha 
for (Iterator<Invariant> j = slice.invs.iterator() ; j.hasNext() ;)
{
  Invariant inv = j.next();
  if (!Daikon.dkconfig_undo_opts)
  {
    if (inv.isObviousStatically_AllInEquality())
    {
      inv.falsify();
      falsified_invs.add(inv);
    }
  }
}haha 
for (Iterator<PptSlice> itor = newSlices.iterator() ; itor.hasNext() ;)
{
  PptSlice slice = itor.next();
  if (slice.invs.size() == 0)
  {
    continue;
  }
  Assert.assertTrue((parent.findSlice(slice.var_infos) == null));
  slice.repCheck();
  parent.addSlice(slice);
}haha 
for (Iterator<Invariant> i = invs.iterator() ; i.hasNext() ;)
{
  Invariant inv = i.next();
  inv.repCheck();
  Assert.assertTrue((inv.ppt == this));
}haha 
5
