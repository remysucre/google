#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPEINT) || defined(TYPEDOUBLE) || defined(TYPESTRING))
  #error "TYPEINT, TYPEDOUBLE, or TYPESTRING must be defined"
#endif

#if defined(TYPEINT)
  #define LIMITEDSIZEINTSET LimitedSizeIntSet
  #define INT int
#elif defined(TYPEDOUBLE)
  #define LIMITEDSIZEINTSET LimitedSizeDoubleSet
  #define INT double
#elif defined(TYPESTRING)
  #define LIMITEDSIZEINTSET LimitedSizeStringSet
  #define INT String
#endif

// ***** This file is automatically generated from LimitedSizeSet.java.jpp

package utilMDE;

import java.io.Serializable;
import java.util.*;


/**
 * LimitedSizeIntSet stores up to some maximum number of unique non-zero
 * integer values, at which point its rep is nulled, in order to save space.
 **/
public class LIMITEDSIZEINTSET
  implements Serializable, Cloneable
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031021L;

  // public final int max_values;

  // If null, then at least num_values distinct values have been seen.
  // The size is not separately stored, because that would take extra space.
  protected INT[] values;
  // The number of active elements (equivalently, the first unused index).
  int num_values;

  public LimitedSizeIntSet(int max_values) {
    Assert.assertTrue(max_values > 0);
    // this.max_values = max_values;
    values = new INT[max_values];
    num_values = 0;
  }

  public void add(INT elt) {
    if (values == null)
      return;

    for (int i=0; i < num_values; i++) {
      if (values[i] == elt) {
        return;
      }
    }
    if (num_values == values.length) {
      values = null;
      num_values++;
      return;
    }
    values[num_values] = elt;
    num_values++;
  }

  public void addAll(LIMITEDSIZEINTSET s) {
    if (repNulled())
      return;
    if (s.repNulled()) {
      if (size() + s.size() >= values.length) {
        num_values = values.length+1;
        values = null;
        return;
      } else {
        throw new Error("Arg is rep-nulled, but isn't enough to rep-null this.");
      }
    }
    for (int i=0; i<s.size(); i++) {
      add(s.values[i]);
      if (repNulled()) {
        return;
      }
    }
  }

  public boolean contains(INT elt) {
    if (values == null) {
      throw new UnsupportedOperationException();
    }
    for (int i=0; i < num_values; i++) {
      if (values[i] == elt) {
        return true;
      }
    }
    return false;
  }


  /**
   * A lower bound on the number of elements in the set.  Returns either
   * the number of elements that have been inserted in the set, or
   * max_size(), whichever is less.
   **/
  public int size() {
    return num_values;
  }

  /**
   * An upper bound how many distinct elements can be individually
   * represented in the set.
   * Returns max_values+1 (where max_values is the argument to the constructor).
   **/
  public int max_size() {
    if (values == null) {
      return num_values;
    } else {
      return values.length + 1;
    }
  }

  public boolean repNulled() {
    return values == null;
  }

  public Object clone() {
    LIMITEDSIZEINTSET result;
    try {
      result = (LIMITEDSIZEINTSET) super.clone();
    } catch (CloneNotSupportedException e) {
      throw new Error(); // can't happen
    }
    result.values = (INT[]) values.clone();
    return result;
  }


  /**
   * Merges a list of LIMITEDSIZEINTSET objects into a single object that
   * represents the values seen by the entire list.  Returns the new
   * object, whose max_values is the given integer.
   **/
  public static LIMITEDSIZEINTSET merge (int max_values, List<LIMITEDSIZEINTSET> slist) {
    LIMITEDSIZEINTSET result = new LIMITEDSIZEINTSET(max_values);
    for (Iterator<LIMITEDSIZEINTSET> itor = slist.iterator(); itor.hasNext(); ) {
      LIMITEDSIZEINTSET s = itor.next();
      result.addAll(s);
    }
    return result;
  }

  public String toString() {
    return ("[size=" + size() + "; " +
            ((values == null) ? "null" : ArraysMDE.toString(values))
            + "]");
  }

}
